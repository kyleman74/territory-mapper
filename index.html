<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Territory Mapper - Google Sheets Connected</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        #map { height: 100%; width: 100%; }
        .leaflet-popup-content { margin: 0; }
        .territory-checkbox:checked + label {
            background-color: #E0E7FF;
            border-color: #6366F1;
        }
        .sync-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .sync-success { background-color: #10B981; }
        .sync-loading { background-color: #F59E0B; animation: pulse 1s infinite; }
        .sync-error { background-color: #EF4444; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .state-select {
            max-height: 200px;
            overflow-y: auto;
        }
        .state-checkbox {
            display: none;
        }
        .state-checkbox:checked + label {
            background-color: #E0E7FF;
            border-color: #6366F1;
        }
    </style>
</head>
<body class="m-0 p-0 font-sans">
    <!-- Google Sheets Configuration -->
    <script>
        // YOUR GOOGLE SHEET CONFIG
        const SHEET_ID = '1cjlRT0sNfkpjzTtxc4qreCPhhv8ZBkXV';
        const SHEET_NAME = 'TerritoryData'; // Update if your sheet tab has a different name
        const API_KEY = 'AIzaSyDEXI2xXp4o7R1vWB3x8XUziKqGGxfxDhM'; // Public API key for reading
    </script>

    <div class="flex flex-col h-screen bg-gray-50">
        <!-- Header -->
        <div class="bg-white shadow-sm border-b">
            <div class="px-6 py-4">
                <h1 class="text-2xl font-bold text-gray-800">Sales Territory Mapper</h1>
                <p class="text-sm text-gray-600 mt-1">
                    Connected to Google Sheets - Changes sync automatically
                    <span id="syncStatus" class="ml-2">
                        <span class="sync-indicator sync-success"></span>
                        <span class="text-xs">Ready</span>
                    </span>
                </p>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="bg-white px-6 py-3 border-b flex items-center gap-4 flex-wrap">
            <button onclick="loadFromGoogleSheets()" 
                    class="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                </svg>
                Refresh from Sheet
            </button>

            <button onclick="saveToGoogleSheets()" 
                    class="flex items-center gap-2 px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path>
                </svg>
                Save to Sheet
            </button>

            <button onclick="toggleDrawingMode()" id="drawBtn"
                    class="flex items-center gap-2 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                </svg>
                <span id="drawBtnText">Select Mode</span>
            </button>

            <select id="premiseFilter" onchange="filterByPremise()" 
                    class="px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="all">All Locations</option>
                <option value="on">On Premise Only</option>
                <option value="off">Off Premise Only</option>
            </select>

            <div class="relative">
                <button onclick="toggleStateFilter()" 
                        class="flex items-center gap-2 px-3 py-2 border rounded-lg hover:bg-gray-50">
                    <span>States</span>
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </button>
                <div id="stateFilterDropdown" class="hidden absolute top-full mt-1 bg-white border rounded-lg shadow-lg z-50 w-48">
                    <div class="p-2">
                        <button onclick="selectAllStates()" class="text-xs text-blue-600 hover:underline">All</button>
                        <button onclick="selectNoStates()" class="ml-2 text-xs text-blue-600 hover:underline">None</button>
                    </div>
                    <div id="stateList" class="state-select p-2 border-t"></div>
                </div>
            </div>

            <select id="sizeMetric" onchange="updateMarkers()" 
                    class="px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="none">Size: Default</option>
                <option value="3 Yr Plan Mrkt Shr">Size: 3 Yr Plan Mrkt Shr</option>
                <option value="Dstar TPV">Size: Dstar TPV</option>
                <option value="PRUSA NNS">Size: PRUSA NNS</option>
            </select>

            <span id="locationCount" class="text-sm text-gray-600"></span>

            <div class="ml-auto">
                <a href="https://docs.google.com/spreadsheets/d/1cjlRT0sNfkpjzTtxc4qreCPhhv8ZBkXV/edit" 
                   target="_blank"
                   class="text-sm text-blue-600 hover:underline">
                    Open Google Sheet â†’
                </a>
            </div>

            <div id="selectionTools" class="hidden items-center gap-2 bg-yellow-50 px-4 py-2 rounded-lg">
                <span id="selectedCount" class="text-sm font-medium text-gray-700"></span>
                <input type="text" id="newTerritory" placeholder="Territory name" 
                       class="px-3 py-1 border rounded focus:outline-none focus:ring-2 focus:ring-orange-500" />
                <datalist id="territories"></datalist>
                <button onclick="reassignTerritory()" 
                        class="flex items-center gap-1 px-3 py-1 bg-orange-500 text-white rounded hover:bg-orange-600 transition-colors">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path>
                    </svg>
                    Reassign
                </button>
                <button onclick="clearSelection()" class="p-1 text-gray-500 hover:text-gray-700">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        </div>

        <div class="flex flex-1 overflow-hidden">
            <!-- Sidebar -->
            <div id="sidebar" class="w-80 bg-white border-r overflow-y-auto">
                <div class="p-4">
                    <h3 class="font-semibold text-gray-800 mb-4">Territory Summary</h3>
                    
                    <div class="mb-6 p-4 bg-gray-50 rounded-lg">
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <p class="text-gray-600">Total Locations</p>
                                <p id="totalLocations" class="text-2xl font-bold text-gray-800">0</p>
                            </div>
                            <div>
                                <p class="text-gray-600">Territories</p>
                                <p id="totalTerritories" class="text-2xl font-bold text-gray-800">0</p>
                            </div>
                        </div>
                    </div>

                    <!-- Territory Filter Controls -->
                    <div class="mb-4 flex gap-2">
                        <button onclick="selectAllTerritories()" class="text-xs px-2 py-1 bg-gray-100 rounded hover:bg-gray-200">
                            Select All
                        </button>
                        <button onclick="selectNoneTerritories()" class="text-xs px-2 py-1 bg-gray-100 rounded hover:bg-gray-200">
                            Select None
                        </button>
                    </div>

                    <div id="territoryList" class="space-y-2"></div>
                </div>
            </div>

            <!-- Map -->
            <div class="flex-1 relative">
                <div id="map"></div>
                
                <div id="drawingModeInfo" class="hidden absolute top-4 right-4 bg-white p-4 rounded-lg shadow-lg z-[1000] max-w-xs">
                    <h4 class="font-semibold text-purple-700 mb-2">Drawing Mode Active</h4>
                    <p class="text-sm text-gray-600">
                        Use the polygon or rectangle tools to select multiple locations at once.
                    </p>
                </div>
                
                <div id="loadingPrompt" class="absolute inset-0 flex items-center justify-center bg-gray-100">
                    <div class="text-center">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                        <p class="text-gray-600 font-medium">Connecting to Google Sheets...</p>
                        <p class="text-sm text-gray-500 mt-2">Loading your territory data</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>

    <script>
        // Global variables
        let map;
        let locations = [];
        let territories = [];
        let states = [];
        let markers = {};
        let selectedLocations = new Set();
        let selectedTerritories = new Set();
        let selectedStates = new Set();
        let premiseFilter = 'all';
        let drawingMode = false;
        let drawnItems;
        let drawControl;
        let territoryColors = {};
        let webAppUrl = null;
        let columnIndices = {};

        // Territory colors
        const DEFAULT_COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
            '#FF9FF3', '#54A0FF', '#48DBFB', '#A29BFE', '#FD79A8',
            '#FDCB6E', '#6C5CE7', '#00B894', '#00CEC9', '#E17055',
            '#74B9FF', '#A29BFE', '#81ECEC', '#FD79A8', '#FDCB6E'
        ];

        // Initialize map
        function initMap() {
            map = L.map('map').setView([39.8283, -98.5795], 4);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            drawControl = new L.Control.Draw({
                draw: {
                    polygon: true,
                    rectangle: true,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    polyline: false
                },
                edit: false
            });

            map.on('draw:created', function(e) {
                const layer = e.layer;
                const bounds = layer.getBounds();
                
                locations.forEach(loc => {
                    const point = L.latLng(loc.lat, loc.lng);
                    if (bounds.contains(point)) {
                        selectedLocations.add(loc.id);
                    }
                });
                
                updateMarkers();
                updateSelectionUI();
                
                setTimeout(() => {
                    drawnItems.removeLayer(layer);
                }, 500);
            });

            // Close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.relative')) {
                    document.getElementById('stateFilterDropdown').classList.add('hidden');
                }
            });
        }

        // Initialize app
        window.onload = function() {
            initMap();
            setupGoogleSheetsWebApp();
            loadFromGoogleSheets();
            
            // Auto-refresh every 30 seconds
            setInterval(loadFromGoogleSheets, 30000);
        };

        // Setup Google Apps Script Web App for writing
        function setupGoogleSheetsWebApp() {
            // This will be the URL of your Google Apps Script Web App
            // We'll create this in the next step
            webAppUrl = 'YOUR_WEB_APP_URL_HERE'; // You'll need to add this after creating the Apps Script
        }

        // Update sync status
        function updateSyncStatus(status, message) {
            const syncStatus = document.getElementById('syncStatus');
            const indicator = syncStatus.querySelector('.sync-indicator');
            const text = syncStatus.querySelector('span:last-child');
            
            indicator.className = 'sync-indicator';
            
            switch(status) {
                case 'loading':
                    indicator.classList.add('sync-loading');
                    break;
                case 'success':
                    indicator.classList.add('sync-success');
                    break;
                case 'error':
                    indicator.classList.add('sync-error');
                    break;
            }
            
            text.textContent = message;
        }

        // Toggle state filter dropdown
        function toggleStateFilter() {
            const dropdown = document.getElementById('stateFilterDropdown');
            dropdown.classList.toggle('hidden');
        }

        // Select all states
        function selectAllStates() {
            selectedStates = new Set(states);
            updateStateUI();
            updateMarkers();
            updateStats();
        }

        // Select no states
        function selectNoStates() {
            selectedStates.clear();
            updateStateUI();
            updateMarkers();
            updateStats();
        }

        // Toggle state selection
        function toggleState(state) {
            if (selectedStates.has(state)) {
                selectedStates.delete(state);
            } else {
                selectedStates.add(state);
            }
            updateMarkers();
            updateStats();
        }

        // Update state UI
        function updateStateUI() {
            const stateList = document.getElementById('stateList');
            stateList.innerHTML = states.map(state => {
                const isChecked = selectedStates.has(state);
                return `
                    <div class="mb-1">
                        <input type="checkbox" 
                               id="state-${state}" 
                               class="state-checkbox"
                               ${isChecked ? 'checked' : ''}
                               onchange="toggleState('${state}')">
                        <label for="state-${state}" 
                               class="block px-2 py-1 text-sm rounded cursor-pointer hover:bg-gray-100 ${isChecked ? 'bg-blue-50 text-blue-700' : ''}">
                            ${state}
                        </label>
                    </div>
                `;
            }).join('');
        }

        // Find column index (search first 24 columns)
        function findColumnIndex(headers, searchTerms) {
            const searchTermsArray = Array.isArray(searchTerms) ? searchTerms : [searchTerms];
            const maxCols = Math.min(headers.length, 24);
            
            for (let i = 0; i < maxCols; i++) {
                if (headers[i]) {
                    const header = headers[i].toLowerCase();
                    for (const term of searchTermsArray) {
                        if (header.includes(term.toLowerCase())) {
                            return i;
                        }
                    }
                }
            }
            return -1;
        }

        // Load data from Google Sheets
        async function loadFromGoogleSheets() {
            updateSyncStatus('loading', 'Loading from Google Sheets...');
            
            try {
                const range = `${SHEET_NAME}!A:AA`; // Get columns A through AA (27 columns)
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/${range}?key=${API_KEY}`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to load data');
                
                const data = await response.json();
                processGoogleSheetsData(data.values);
                
                updateSyncStatus('success', 'Loaded successfully');
                document.getElementById('loadingPrompt').classList.add('hidden');
                
            } catch (error) {
                console.error('Load error:', error);
                updateSyncStatus('error', 'Failed to load');
                alert('Error loading from Google Sheets. Check console for details.');
            }
        }

        // Process Google Sheets data
        function processGoogleSheetsData(values) {
            if (!values || values.length < 2) return;
            
            const headers = values[0];
            const rows = values.slice(1);
            
            // Find column indices (search first 24 columns for name)
            columnIndices = {
                name: findColumnIndex(headers, ['name', 'account', 'location', 'store']),
                licensee: findColumnIndex(headers, ['licensee', 'owner', 'operator']),
                lat: findColumnIndex(headers, ['lat', 'latitude']),
                lng: findColumnIndex(headers, ['lng', 'lon', 'longitude']),
                territory: findColumnIndex(headers, ['territory', 'region']),
                premise: findColumnIndex(headers, ['premise', 'on-premise', 'off-premise', 'type']),
                state: findColumnIndex(headers, ['state', 'province']),
                planMrktShr: findColumnIndex(headers, ['3 yr plan mrkt', '3 year plan', 'plan mrkt shr']),
                dstarTPV: findColumnIndex(headers, ['dstar tpv', 'dstar']),
                prusaNNS: findColumnIndex(headers, ['prusa nns', 'prusa'])
            };
            
            locations = rows
                .filter(row => row[columnIndices.lat] && row[columnIndices.lng])
                .map((row, index) => ({
                    id: index,
                    row: index + 2, // Google Sheets row number (1-indexed, plus header)
                    name: row[columnIndices.name] || `Location ${index + 1}`,
                    licensee: columnIndices.licensee >= 0 ? row[columnIndices.licensee] : '',
                    lat: parseFloat(row[columnIndices.lat]),
                    lng: parseFloat(row[columnIndices.lng]),
                    territory: row[columnIndices.territory] || 'Unassigned',
                    premise: columnIndices.premise >= 0 ? detectPremiseType(row[columnIndices.premise]) : 'unknown',
                    state: columnIndices.state >= 0 ? row[columnIndices.state] : '',
                    planMrktShr: columnIndices.planMrktShr >= 0 ? parseFloat(row[columnIndices.planMrktShr]) || 0 : 0,
                    dstarTPV: columnIndices.dstarTPV >= 0 ? parseFloat(row[columnIndices.dstarTPV]) || 0 : 0,
                    prusaNNS: columnIndices.prusaNNS >= 0 ? parseFloat(row[columnIndices.prusaNNS]) || 0 : 0
                }));

            // Extract unique values
            territories = [...new Set(locations.map(loc => loc.territory))];
            states = [...new Set(locations.map(loc => loc.state).filter(s => s))].sort();
            
            // Initialize colors
            territories.forEach((territory, index) => {
                if (!territoryColors[territory]) {
                    territoryColors[territory] = DEFAULT_COLORS[index % DEFAULT_COLORS.length];
                }
            });
            
            // Initialize selections
            selectedTerritories = new Set(territories);
            if (selectedStates.size === 0) {
                selectedStates = new Set(states);
            }
            
            updateUI();
            updateMarkers();
            
            if (locations.length > 0) {
                const bounds = L.latLngBounds(locations.map(loc => [loc.lat, loc.lng]));
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // Save data to Google Sheets
        async function saveToGoogleSheets() {
            if (!webAppUrl || webAppUrl === 'YOUR_WEB_APP_URL_HERE') {
                alert('To enable saving, you need to set up a Google Apps Script Web App. For now, data is read-only.');
                return;
            }
            
            updateSyncStatus('loading', 'Saving to Google Sheets...');
            
            try {
                // Prepare data for Google Sheets
                const values = locations.map(loc => ({
                    row: loc.row,
                    territory: loc.territory
                }));
                
                const response = await fetch(webAppUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'update',
                        data: values
                    })
                });
                
                updateSyncStatus('success', 'Saved successfully');
                
                // Reload to confirm changes
                setTimeout(loadFromGoogleSheets, 1000);
                
            } catch (error) {
                console.error('Save error:', error);
                updateSyncStatus('error', 'Failed to save');
                alert('Error saving to Google Sheets. Check console for details.');
            }
        }

        // Detect premise type
        function detectPremiseType(value) {
            if (!value) return 'unknown';
            const val = value.toString().toLowerCase();
            if (val.includes('on') || val === '1' || val === 'true' || val === 'on-premise') return 'on';
            if (val.includes('off') || val === '0' || val === 'false' || val === 'off-premise') return 'off';
            return 'unknown';
        }

        // Update UI
        function updateUI() {
            // Update datalist
            const datalist = document.getElementById('territories');
            datalist.innerHTML = territories.map(t => `<option value="${t}">`).join('');
            document.getElementById('newTerritory').setAttribute('list', 'territories');

            // Update state filter
            updateStateUI();

            // Update stats
            updateStats();
            updateLocationCount();
        }

        // Get marker size based on metric
        function getMarkerSize(location) {
            const sizeMetric = document.getElementById('sizeMetric').value;
            if (sizeMetric === 'none') return 8;
            
            let value = 0;
            switch(sizeMetric) {
                case '3 Yr Plan Mrkt Shr':
                    value = location.planMrktShr;
                    break;
                case 'Dstar TPV':
                    value = location.dstarTPV;
                    break;
                case 'PRUSA NNS':
                    value = location.prusaNNS;
                    break;
            }
            
            // Minimum size of 4, scale up based on value
            const minSize = 4;
            const maxSize = 20;
            const scaledSize = minSize + (Math.sqrt(value) / 50); // Adjust scaling factor as needed
            return Math.min(Math.max(scaledSize, minSize), maxSize);
        }

        // Update markers
        function updateMarkers() {
            // Clear existing markers
            Object.values(markers).forEach(marker => map.removeLayer(marker));
            markers = {};

            const locationsToShow = locations.filter(loc => {
                // State filter
                if (selectedStates.size > 0 && !selectedStates.has(loc.state)) return false;
                
                // Territory filter
                if (!selectedTerritories.has(loc.territory)) return false;
                
                // Premise filter
                if (premiseFilter !== 'all') {
                    if (premiseFilter === 'on' && loc.premise !== 'on') return false;
                    if (premiseFilter === 'off' && loc.premise !== 'off') return false;
                }
                
                return true;
            });

            locationsToShow.forEach(location => {
                const color = territoryColors[location.territory] || getTerritoryColor(location.territory);
                const isSelected = selectedLocations.has(location.id);
                const size = getMarkerSize(location);
                
                let marker;
                
                const options = {
                    radius: size,
                    fillColor: color,
                    color: isSelected ? '#000' : '#fff',
                    weight: isSelected ? 3 : 2,
                    opacity: 1,
                    fillOpacity: 0.8
                };
                
                // On-premise = circle, Off-premise = square
                if (location.premise === 'on') {
                    marker = L.circleMarker([location.lat, location.lng], options);
                } else {
                    // Create square marker
                    const latOffset = size * 0.00015;
                    const lngOffset = size * 0.00015;
                    marker = L.rectangle([
                        [location.lat - latOffset, location.lng - lngOffset],
                        [location.lat + latOffset, location.lng + lngOffset]
                    ], options);
                }

                const premiseLabel = location.premise === 'on' ? 'On Premise' : 
                                   location.premise === 'off' ? 'Off Premise' : 'Unknown';

                const sizeMetric = document.getElementById('sizeMetric').value;
                let sizeInfo = '';
                if (sizeMetric !== 'none') {
                    let value = 0;
                    switch(sizeMetric) {
                        case '3 Yr Plan Mrkt Shr':
                            value = location.planMrktShr;
                            break;
                        case 'Dstar TPV':
                            value = location.dstarTPV;
                            break;
                        case 'PRUSA NNS':
                            value = location.prusaNNS;
                            break;
                    }
                    sizeInfo = `<p style="margin: 0 0 3px 0; font-size: 0.875rem;"><strong>${sizeMetric}:</strong> $${value.toLocaleString()}</p>`;
                }

                marker.bindPopup(`
                    <div style="padding: 12px; min-width: 200px;">
                        ${location.licensee ? `<h3 style="font-weight: 700; margin: 0 0 8px 0; font-size: 1.1rem; color: #1f2937;">${location.licensee}</h3>` : ''}
                        <h4 style="font-weight: 600; margin: 0 0 6px 0; color: #4b5563;">${location.name}</h4>
                        <div style="border-top: 1px solid #e5e7eb; margin: 6px 0; padding-top: 6px;">
                            <p style="margin: 0 0 3px 0; font-size: 0.875rem;"><strong>Territory:</strong> ${location.territory}</p>
                            <p style="margin: 0 0 3px 0; font-size: 0.875rem;"><strong>Type:</strong> ${premiseLabel}</p>
                            <p style="margin: 0 0 3px 0; font-size: 0.875rem;"><strong>State:</strong> ${location.state || 'N/A'}</p>
                            ${sizeInfo}
                            <p style="margin: 0; font-size: 0.75rem; color: #6b7280;">
                                ${location.lat.toFixed(4)}, ${location.lng.toFixed(4)}
                            </p>
                        </div>
                    </div>
                `);

                marker.on('click', function() {
                    if (!drawingMode) {
                        if (selectedLocations.has(location.id)) {
                            selectedLocations.delete(location.id);
                        } else {
                            selectedLocations.add(location.id);
                        }
                        updateMarkers();
                        updateSelectionUI();
                    }
                });

                marker.addTo(map);
                markers[location.id] = marker;
            });

            updateLocationCount();
        }

        // Territory color
        function getTerritoryColor(territory) {
            const index = territories.indexOf(territory);
            return DEFAULT_COLORS[index % DEFAULT_COLORS.length];
        }

        // Toggle drawing mode
        function toggleDrawingMode() {
            drawingMode = !drawingMode;
            const btn = document.getElementById('drawBtn');
            const info = document.getElementById('drawingModeInfo');
            
            if (drawingMode) {
                map.addControl(drawControl);
                btn.classList.remove('bg-gray-200', 'text-gray-700');
                btn.classList.add('bg-purple-500', 'text-white');
                document.getElementById('drawBtnText').textContent = 'Drawing Mode';
                info.classList.remove('hidden');
            } else {
                map.removeControl(drawControl);
                btn.classList.remove('bg-purple-500', 'text-white');
                btn.classList.add('bg-gray-200', 'text-gray-700');
                document.getElementById('drawBtnText').textContent = 'Select Mode';
                info.classList.add('hidden');
            }
        }

        // Filter by premise
        function filterByPremise() {
            premiseFilter = document.getElementById('premiseFilter').value;
            updateMarkers();
        }

        // Update stats
        function updateStats() {
            // Get filtered locations by state
            const stateFilteredLocations = locations.filter(loc => 
                selectedStates.size === 0 || selectedStates.has(loc.state)
            );
            
            document.getElementById('totalLocations').textContent = stateFilteredLocations.length;
            
            // Get territories that have locations in selected states
            const validTerritories = [...new Set(stateFilteredLocations.map(loc => loc.territory))];
            document.getElementById('totalTerritories').textContent = validTerritories.length;

            const stats = _.groupBy(stateFilteredLocations, 'territory');
            const territoryList = document.getElementById('territoryList');
            
            territoryList.innerHTML = validTerritories
                .sort()
                .map(territory => {
                    const locs = stats[territory] || [];
                    const percentage = stateFilteredLocations.length > 0 
                        ? ((locs.length / stateFilteredLocations.length) * 100).toFixed(1)
                        : 0;
                    const isChecked = selectedTerritories.has(territory);
                    
                    return `
                        <div class="flex items-center space-x-2">
                            <input type="checkbox" 
                                   id="territory-${territory}" 
                                   class="territory-checkbox hidden"
                                   ${isChecked ? 'checked' : ''}
                                   onchange="toggleTerritory('${territory}')">
                            <label for="territory-${territory}" 
                                   class="flex-1 flex items-center justify-between p-3 rounded-lg cursor-pointer border-2 border-gray-200 hover:border-gray-300 transition-all">
                                <div class="flex items-center gap-3">
                                    <div class="w-4 h-4 rounded" style="background-color: ${territoryColors[territory] || getTerritoryColor(territory)}"></div>
                                    <div>
                                        <p class="font-medium text-sm">${territory}</p>
                                        <p class="text-xs text-gray-500">${percentage}% of total</p>
                                    </div>
                                </div>
                                <span class="text-sm font-medium text-gray-700">${locs.length}</span>
                            </label>
                        </div>
                    `;
                }).join('');
        }

        // Toggle territory selection
        function toggleTerritory(territory) {
            if (selectedTerritories.has(territory)) {
                selectedTerritories.delete(territory);
            } else {
                selectedTerritories.add(territory);
            }
            updateMarkers();
        }

        // Select all territories
        function selectAllTerritories() {
            // Only select territories that are visible (have locations in selected states)
            const stateFilteredLocations = locations.filter(loc => 
                selectedStates.size === 0 || selectedStates.has(loc.state)
            );
            const validTerritories = [...new Set(stateFilteredLocations.map(loc => loc.territory))];
            selectedTerritories = new Set(validTerritories);
            updateStats();
            updateMarkers();
        }

        // Select no territories
        function selectNoneTerritories() {
            selectedTerritories.clear();
            updateStats();
            updateMarkers();
        }

        // Update location count
        function updateLocationCount() {
            const count = locations.filter(loc => {
                if (selectedStates.size > 0 && !selectedStates.has(loc.state)) return false;
                if (!selectedTerritories.has(loc.territory)) return false;
                if (premiseFilter !== 'all') {
                    if (premiseFilter === 'on' && loc.premise !== 'on') return false;
                    if (premiseFilter === 'off' && loc.premise !== 'off') return false;
                }
                return true;
            }).length;
            
            document.getElementById('locationCount').textContent = `${count} locations shown`;
        }

        // Update selection UI
        function updateSelectionUI() {
            const tools = document.getElementById('selectionTools');
            if (selectedLocations.size > 0) {
                tools.classList.remove('hidden');
                tools.classList.add('flex');
                document.getElementById('selectedCount').textContent = `${selectedLocations.size} selected`;
            } else {
                tools.classList.add('hidden');
                tools.classList.remove('flex');
            }
        }

        // Reassign territory
        function reassignTerritory() {
            const newTerritory = document.getElementById('newTerritory').value;
            if (!newTerritory || selectedLocations.size === 0) return;

            locations = locations.map(loc => {
                if (selectedLocations.has(loc.id)) {
                    return { ...loc, territory: newTerritory };
                }
                return loc;
            });

            if (!territories.includes(newTerritory)) {
                territories.push(newTerritory);
                territoryColors[newTerritory] = DEFAULT_COLORS[territories.length % DEFAULT_COLORS.length];
                selectedTerritories.add(newTerritory);
            }

            selectedLocations.clear();
            updateUI();
            updateMarkers();
            updateSelectionUI();
            document.getElementById('newTerritory').value = '';
            
            // Auto-save after reassignment
            saveToGoogleSheets();
        }

        // Clear selection
        function clearSelection() {
            selectedLocations.clear();
            updateMarkers();
            updateSelectionUI();
        }
    </script>
</body>
</html>
